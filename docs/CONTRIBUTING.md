# Contributing

This document is intended to give guidelines for those who are willing to contribute in the development of TCG.
It is divided in three parts:
- **Installation and usage** (how to prepare your computer for locally running the game and tests)
- **Project architecture** (which tools we use, and why)
- **Project structure** (how is the project organized)
- **Development practices** (what is expected from you as a collaborator when programming TCG)

## Installation and usage

You'll need to have the repository locally cloned: `git clone https://github.com/kenan-rhoton/card-game`

### Leiningen

To work on the backend you'll need to install [Leiningen](https://leiningen.org/)

### Yarn

To work on the frontend you'll need to install [Yarn](https://yarnpkg.com/)

### Usage

`lein ring server-headless` to execute the backend's ring server (from within the backend directory)

`yarn start` to execute the frontend server (from within the frontend directory)

### Tests

While working on backend stuff (Clojure), please keep a terminal open at *all* times with the following command running:

`lein test-refresh`

While working on frontend stuff (Javascript), please keep a terminal open at *all* times with the following command running:

`yarn test-refresh`

This will give you instant feedback through the tests.

### Code-review tools

We have installed on the project a couple of tools to help us review the code.

- *Cloverage*: Run `lein cloverage` from `backend/` to get a report of how well our code is being tested.
- *Yagni*: Run `lein yagni` from `backend/` to get a report of which functions are not being used.
- *Eastwood*: Run `lein eastwood` from `backend/` to get a report of possible errors in your implementation and pain points.

## Project architecture

The project is divided (as of now) into two main sections: *backend* and *frontend*, each with their quirks.

### Backend architecture

We use [Clojure](https://www.braveclojure.com) as the backend language for pretty much **everything** due to basically two reasons:

1. Because of the "everything is immutable" paradigm, it's very easy to reason about the logic of the code, which will probably get very complex as time goes on.
2. Due to its functional nature, it is *very* easy to run tests on it and a strict [TDD](https://www.youtube.com/watch?v=qkblc5WRn-U) discipline.

The backend also uses [Redis](https://redis.io) as a key-value storage mechanism for any persistent information necessary (such as the state of a game) since we will *always* know exactly what key we're searching for (we'll know the game ID, player ID, etc.).

Finally, the backend uses [Compojure](https://github.com/weavejester/compojure) to define it's [REST API](http://www.restapitutorial.com), which is the way the *frontend* will communicate with it.

### Frontend architecture

Frontend uses Webpack to power Jest (for the unit tests), Pug (to have an extensible replacement for HTML) and to have a Server.

## Project structure

The structure of a project (where the f*** is that file?) might be more important than it's architecture. In this case, there is a three-way split: *backend* and *frontend* as before, but we also have de *e2e* tests to worry about.

But some things also happen at the root:

- **docker-compose.yml**: Defines how the different parts of the project launch and interact with each other.
- **.travis.yml**: Defines how the different pars of the project are to be tested.

However, we will understand this further in the following sections.

### Backend structure

- **backend/Dockerfile**: Defines how the Docker image for the backend will be built and run
- **backend/project.clj**: Defines the project dependencies and entry point
- **backend/test/**: Contains all the unit tests for the code, following the same structure as src/. Remember that a unit test must be done *before* the actual code.
- **backend/src/rules**: Contains the code that will run in production, the actual logic.
- **backend/src/persistence/persistence.clj**: This is the only file to interact directly with the database. All database calls *must* pass through here.
- **backend/src/api/handler.clj**: This is the only file to interact directly with frontend. Any actions to take as a response to a frontend call *must* be defined here.

### Frontend structure

- **frontend/Dockerfile** and **frontend/entry.sh**: Defines the Docker image and its entrypoint.
- **frontend/package.json** and **frontend/yarn.lock**: Define the project dependencies (`yarn.lock` is autogenerated by `yarn`)
- **frontend/test/unit/**: Contains all the unit tests for the code. Remember that a unit test must be done *before* the actual code.
- **frontend/public/**: The "website", with `index.html` being the entrypoint, but the real magic happens elsewhere...
- **frontend/src/**: Contains the code that will run in production, with its own structure.
- **frontend/src/main.js**: The official entrypoint for Vue. Should only be modified if we add a dependency that works through `Vue.use(dependency)`
- **frontend/src/router.js**: Here the "routes" are defined, which is the way Vue interprets what component or view to serve based on the URL (for example `http://frontend:8080/#/create-game` points to the CreateGame component)
- **frontend/src/App.vue**: The main Vue component. Since we're mostly using everything through `router` this mainly hosts the `<router-view/>` (which renders the component the `router` has decided upon based on our URL) and little else.
- **frontend/src/components/** and **frontend/src/views**: The application logic, separated into "views" and "components" following no good criteria as of yet, we will improve on this in the future.


## Development practices

For any change or contribution, this is what is expected of you:

1. Announce within an issue that you want it assigned to you (or open said issue yourself).
2. Do not take on more than one issue at a time
3. Design the tests for your issue (unit tests always and in some cases e2e tests may be required)
4. Make them pass
5. Ask for a review from a collaborator
6. If changes are requested or travis does not pass, go to 3.

We will value the following things on your contribution *in this order*:

1. The tests pass
2. The code has tests
3. The tests are well-designed
4. The code is readable
5. The code is well-organized
6. The code works and fixes the issue
7. Any rule changed or included is also on the [Manual](https://github.com/kenan-rhoton/card-game/wiki/0.-Troll:-Card-Game-Rules)

If at any point you have a question, please ask it if possible through a comment so others may benefit from the answer.

### Other notes

1. We use a strict [TDD](http://www.javiersaldana.com/tech/2014/11/26/refactoring-the-three-laws-of-tdd.html) discipline to contribute to this project, and we expect at *least* that level of tests from any contribution. If we believe the tests don't cover enough production cases, you will be asked to review your code.
2. All merges should be done to the *develop* branch. There, e2e tests are not ensure to work correctly. That allows us to work in parallel on *backend* and *frontend*. When e2e passes on *develop*, a merge is done to *master*.
3. We always merge through `Squash & Merge`, which will cause you conflicts if you make a pull request from your personal fork's  master branch. We will warn you about this if we see it, as we think it's much more convenient to use your master branch *purely* to be up to date with ours and to make a branch for each feature.
